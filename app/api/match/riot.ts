import { Match, Team } from "../types";
import { z } from "zod";

export async function retrieveMatchFromRiot(matchId: string, apiKey: string): Promise<Match> {
  const response = await fetch(`https://na.api.riotgames.com/val/match/v1/matches/${matchId}`, {
    headers: {
      "X-Riot-Token": apiKey
    }
  });
  if (response.status !== 200) {
    throw Error(response.status.toString()); // TODO
  }
  const riotMatch = riotMatchSchema.parse(await response.json());
  return convertMatch(riotMatch);
}

function convertMatch(riotMatch: z.infer<typeof riotMatchSchema>): Match {
  const playerIndex: Map<string, { team: Team; }> = riotMatch.players.reduce(
    (index, player) => {
      index.set(player.puuid, {
        team: parseTeam(player.teamId)
      });
      return index;
    },
    new Map<string, { team: Team; }>());
  return {
    map: riotMatch.matchInfo.mapId,
    teams: {
      red: {
        won: findOrThrow(riotMatch.teams, t => t.teamId.toLowerCase() === "red").won,
        roundsWon: 0,
        roundsLost: 0
      },
      blue: {
        won: findOrThrow(riotMatch.teams, t => t.teamId.toLowerCase() === "blue").won,
        roundsWon: 0,
        roundsLost: 0,
        premierTeamId: undefined
      }
    },
    rounds: riotMatch.roundResults.map(roundResult => ({
      winningTeam: parseTeam(roundResult.winningTeam),
      playerStats: roundResult.playerStats.map(playerStats => ({
        puuid: playerStats.puuid,
        kills: playerStats.kills.map(kill => ({
          timeSinceRoundStartMillis: kill.timeSinceRoundStartMillis,
          victimPuuid: kill.victim,
          victimTeam: playerIndex.get(kill.victim)!.team, // TODO fail fast
          victimLocation: kill.victimLocation,
          playerLocations: kill.playerLocations.map(l => ({
            puuid: l.puuid,
            team: playerIndex.get(l.puuid)!.team,
            location: l.location
          }))
        }))
      }))
    })),
    players: {
      red: riotMatch.players
        .filter(p => p.teamId.toLowerCase() === "red")
        .map(p => ({
          character: p.characterId // TODO translate to character name
        })),
      blue: riotMatch.players
        .filter(p => p.teamId.toLowerCase() === "blue")
        .map(p => ({
          character: p.characterId // TODO translate to character name
        })),
    }
  };
}

function parseTeam(teamString: string): Team {
  return z.literal("red").or(z.literal("blue")).parse(teamString.toLowerCase());
}

function findOrThrow<T>(array: T[], predicate: (value: T) => boolean): T {
  const result = array.find(predicate);
  if (!result) {
    throw Error(`No element in array matches predicate.`);
  }
  return result;
}

// generated by https://transform.tools/json-to-zod
const riotMatchSchema = z.object({
  matchInfo: z.object({
    matchId: z.string(),
    mapId: z.string(),
    gameVersion: z.string(),
    gameLengthMillis: z.number(),
    region: z.string(),
    gameStartMillis: z.number(),
    provisioningFlowId: z.string(),
    isCompleted: z.boolean(),
    customGameName: z.string(),
    queueId: z.string(),
    gameMode: z.string(),
    isRanked: z.boolean(),
    seasonId: z.string(),
    premierMatchInfo: z.object({
      premierSeasonId: z.string(),
      premierEventId: z.string()
    })
  }),
  players: z.array(
    z.object({
      puuid: z.string(),
      gameName: z.string(),
      tagLine: z.string(),
      teamId: z.string(),
      partyId: z.string(),
      characterId: z.string(),
      stats: z.object({
        score: z.number(),
        roundsPlayed: z.number(),
        kills: z.number(),
        deaths: z.number(),
        assists: z.number(),
        playtimeMillis: z.number(),
        abilityCasts: z.object({
          grenadeCasts: z.number(),
          ability1Casts: z.number(),
          ability2Casts: z.number(),
          ultimateCasts: z.number()
        })
      }),
      competitiveTier: z.number(),
      isObserver: z.boolean(),
      playerCard: z.string(),
      playerTitle: z.string(),
      accountLevel: z.number()
    })
  ),
  coaches: z.array(z.unknown()),
  teams: z.array(
    z.object({
      teamId: z.string(),
      won: z.boolean(),
      roundsPlayed: z.number(),
      roundsWon: z.number(),
      numPoints: z.number()
    })
  ),
  roundResults: z.array(
    z.object({
      roundNum: z.number(),
      roundResult: z.string(),
      roundCeremony: z.string(),
      winningTeam: z.string(),
      bombPlanter: z.string().or(z.null()),
      bombDefuser: z.string().or(z.null()),
      plantRoundTime: z.number(),
      plantPlayerLocations: z.array(
        z.object({
          puuid: z.string(),
          viewRadians: z.number(),
          location: z.object({ x: z.number(), y: z.number() })
        })
      ).or(z.null()),
      plantLocation: z.object({ x: z.number(), y: z.number() }),
      plantSite: z.string(),
      defuseRoundTime: z.number(),
      defusePlayerLocations: z.array(
        z.object({
          puuid: z.string(),
          viewRadians: z.number(),
          location: z.object({ x: z.number(), y: z.number() })
        })
      ).or(z.null()),
      defuseLocation: z.object({ x: z.number(), y: z.number() }),
      playerStats: z.array(
        z.object({
          puuid: z.string(),
          kills: z.array(
            z.object({
              timeSinceGameStartMillis: z.number(),
              timeSinceRoundStartMillis: z.number(),
              killer: z.string(),
              victim: z.string(),
              victimLocation: z.object({ x: z.number(), y: z.number() }),
              assistants: z.array(z.string()),
              playerLocations: z.array(
                z.object({
                  puuid: z.string(),
                  viewRadians: z.number(),
                  location: z.object({ x: z.number(), y: z.number() })
                })
              ),
              finishingDamage: z.object({
                damageType: z.string(),
                damageItem: z.string(),
                isSecondaryFireMode: z.boolean()
              })
            })
          ),
          damage: z.array(
            z.object({
              receiver: z.string(),
              damage: z.number(),
              legshots: z.number(),
              bodyshots: z.number(),
              headshots: z.number()
            })
          ),
          score: z.number(),
          economy: z.object({
            loadoutValue: z.number(),
            weapon: z.string(),
            armor: z.string(),
            remaining: z.number(),
            spent: z.number()
          }),
          ability: z.object({
            grenadeEffects: z.null(),
            ability1Effects: z.null(),
            ability2Effects: z.null(),
            ultimateEffects: z.null()
          })
        })
      ),
      roundResultCode: z.string()
    })
  )
});
